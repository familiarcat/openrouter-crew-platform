/**
 * Project Management System
 * 
 * Each project generated by the factory has:
 * - Its own category/domain scorecard
 * - Development progress tracking
 * - Self-similar dashboard structure
 */

import { Category, categories } from './categories';

// Project lifecycle stages
export type ProjectStatus = 'draft' | 'active' | 'paused' | 'completed' | 'archived';

// Source of project creation
export type ProjectSource = 'conceptualize' | 'structured' | 'youtube' | 'rapid' | 'imported';

// Domain scores (same structure as categories but project-specific)
export interface DomainScores {
  demand: number;      // 1-10: Market demand
  effort: number;      // 1-10: Implementation effort
  monetization: number; // 1-10: Revenue potential
  differentiation: number; // 1-10: Competitive advantage
  risk: number;        // 1-10: Risk level
}

// Individual domain within a project
export interface ProjectDomain {
  slug: string;
  name: string;
  description: string;
  scores: DomainScores;
  features: string[];
  status: 'planned' | 'in-progress' | 'completed';
  progress: number; // 0-100
}

// Crew member assignment to a project
export interface CrewAssignment {
  crewMemberId?: string; // Legacy support
  memberId?: string;     // Alternate field name
  role: string;
  assignedAt?: string;
  assignment?: string;   // Task description
  contributions?: string[];
}

// Monetization strategy for a project
export interface MonetizationPlan {
  model: string; // 'saas' | 'consulting' | 'marketplace' | 'freemium' | 'enterprise'
  targetPrice: string;
  revenueStreams: string[];
  timeline: string;
}

// Tech stack for a project
export interface TechStack {
  frontend: string[];
  backend: string[];
  infrastructure: string[];
  ai: string[];
  other: string[];
}

// Main Project interface
export interface Project {
  id: string;
  name: string;
  tagline: string;
  description: string;
  
  // Hierarchy
  parentId?: string; // Parent project ID (null for root/factory)
  isFactory?: boolean; // True for the meta-factory project
  
  // Creation context
  source: ProjectSource;
  sourceUrl?: string; // For YouTube-derived projects
  createdAt: string;
  updatedAt: string;
  
  // Status and progress
  status: ProjectStatus;
  progress: number; // 0-100 overall completion
  
  // Category/Domain mapping
  primaryCategory: string; // slug from categories
  domains: ProjectDomain[];
  
  // Scorecard (aggregated from domains)
  scores: DomainScores;
  
  // Team
  crew: CrewAssignment[];
  
  // Business
  monetization: MonetizationPlan;
  targetMarket: string[];
  
  // Technical
  techStack: TechStack;
  
  // Features and milestones
  mvpFeatures: string[];
  completedFeatures: string[];
  milestones: ProjectMilestone[];
  
  // Metrics
  successMetrics: string[];
  
  // Notes and context
  notes: string;
  tags: string[];
}

export interface ProjectMilestone {
  id: string;
  title?: string;       // Original field
  name?: string;        // Alternate field name
  description?: string;
  targetDate?: string;
  date?: string;        // Alternate field name
  completedAt?: string;
  status: 'pending' | 'in-progress' | 'completed';
}

// Summary view for lists
export interface ProjectSummary {
  id: string;
  name: string;
  tagline: string;
  status: ProjectStatus;
  progress: number;
  primaryCategory: string;
  scores: DomainScores;
  createdAt: string;
  updatedAt: string;
  source: ProjectSource;
  parentId?: string;
  isFactory?: boolean;
  domainCount: number;
}

/**
 * Calculate aggregate scores from project domains
 */
export function calculateProjectScores(domains: ProjectDomain[]): DomainScores {
  if (domains.length === 0) {
    return { demand: 5, effort: 5, monetization: 5, differentiation: 5, risk: 5 };
  }
  
  const avg = (key: keyof DomainScores) => 
    Math.round(domains.reduce((sum, d) => sum + d.scores[key], 0) / domains.length);
  
  return {
    demand: avg('demand'),
    effort: avg('effort'),
    monetization: avg('monetization'),
    differentiation: avg('differentiation'),
    risk: avg('risk'),
  };
}

/**
 * Calculate overall project progress from domains
 */
export function calculateProjectProgress(domains: ProjectDomain[]): number {
  if (domains.length === 0) return 0;
  return Math.round(domains.reduce((sum, d) => sum + d.progress, 0) / domains.length);
}

/**
 * Create a new project with defaults based on category
 */
export function createProject(
  name: string,
  categorySlug: string,
  source: ProjectSource,
  options: Partial<Project> = {}
): Project {
  const category = categories.find(c => c.slug === categorySlug);
  const now = new Date().toISOString();
  
  // Generate default domains from category
  const defaultDomains: ProjectDomain[] = category ? [{
    slug: 'core',
    name: 'Core Functionality',
    description: `Primary ${category.name} implementation`,
    scores: { ...category.scores },
    features: [],
    status: 'planned',
    progress: 0,
  }] : [];
  
  return {
    id: `proj_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
    name,
    tagline: options.tagline || `A ${category?.name || 'new'} project`,
    description: options.description || '',
    
    source,
    sourceUrl: options.sourceUrl,
    createdAt: now,
    updatedAt: now,
    
    status: 'draft',
    progress: 0,
    
    primaryCategory: categorySlug,
    domains: options.domains || defaultDomains,
    scores: category?.scores || { demand: 5, effort: 5, monetization: 5, differentiation: 5, risk: 5 },
    
    crew: options.crew || [],
    
    monetization: options.monetization || {
      model: 'saas',
      targetPrice: 'TBD',
      revenueStreams: [],
      timeline: 'TBD',
    },
    targetMarket: options.targetMarket || [],
    
    techStack: options.techStack || {
      frontend: ['Next.js', 'React', 'TypeScript'],
      backend: ['Node.js', 'Next.js API'],
      infrastructure: ['AWS', 'Docker'],
      ai: [],
      other: [],
    },
    
    mvpFeatures: options.mvpFeatures || [],
    completedFeatures: [],
    milestones: options.milestones || [],
    
    successMetrics: options.successMetrics || [],
    notes: options.notes || '',
    tags: options.tags || [],
  };
}

/**
 * Convert full project to summary for lists
 */
export function toProjectSummary(project: Project): ProjectSummary {
  return {
    id: project.id,
    name: project.name,
    tagline: project.tagline,
    status: project.status,
    progress: project.progress,
    primaryCategory: project.primaryCategory,
    scores: project.scores,
    createdAt: project.createdAt,
    updatedAt: project.updatedAt,
    source: project.source,
    parentId: project.parentId,
    isFactory: project.isFactory,
    domainCount: project.domains.length,
  };
}

/**
 * Get category details for a project
 */
export function getProjectCategory(project: Project): Category | undefined {
  return categories.find(c => c.slug === project.primaryCategory);
}

/**
 * Score label helpers
 */
export function getScoreLabel(score: number): string {
  if (score >= 8) return 'Excellent';
  if (score >= 6) return 'Good';
  if (score >= 4) return 'Moderate';
  if (score >= 2) return 'Low';
  return 'Minimal';
}

export function getScoreColor(score: number): string {
  if (score >= 8) return '#10b981'; // green
  if (score >= 6) return '#3b82f6'; // blue
  if (score >= 4) return '#f59e0b'; // amber
  if (score >= 2) return '#f97316'; // orange
  return '#ef4444'; // red
}

export function getStatusColor(status: ProjectStatus): string {
  switch (status) {
    case 'active': return '#10b981';
    case 'draft': return '#6b7280';
    case 'paused': return '#f59e0b';
    case 'completed': return '#3b82f6';
    case 'archived': return '#9ca3af';
    default: return '#6b7280';
  }
}

export function getStatusIcon(status: ProjectStatus): string {
  switch (status) {
    case 'active': return 'ðŸš€';
    case 'draft': return 'ðŸ“';
    case 'paused': return 'â¸ï¸';
    case 'completed': return 'âœ…';
    case 'archived': return 'ðŸ“¦';
    default: return 'ðŸ“„';
  }
}

// Factory Project ID (constant)
export const FACTORY_PROJECT_ID = 'factory';

/**
 * The Factory Project - the meta-project that manages all other projects
 * Uses categories as its domains
 */
export function createFactoryProject(): Project {
  const factoryDomains: ProjectDomain[] = categories.map(cat => ({
    slug: cat.slug,
    name: cat.name,
    description: cat.tagline,
    scores: { ...cat.scores },
    features: cat.buyers,
    status: 'in-progress' as const,
    progress: 25, // Default progress
  }));

  const avgScores = calculateProjectScores(factoryDomains);

  return {
    id: FACTORY_PROJECT_ID,
    name: 'RAG Refresh Product Factory',
    tagline: 'The meta-application that builds and maintains domain-driven projects',
    description: `This is the factory itself - the project that generates and manages all other projects. 
Its domains are the core categories that define the types of projects we can create.
Each generated project inherits this same structure, enabling recursive self-improvement.`,
    
    isFactory: true,
    
    source: 'imported',
    createdAt: '2024-01-01T00:00:00.000Z',
    updatedAt: new Date().toISOString(),
    
    status: 'active',
    progress: calculateProjectProgress(factoryDomains),
    
    primaryCategory: '',
    domains: factoryDomains,
    scores: avgScores,
    
    crew: [
      { crewMemberId: 'captain_picard', role: 'Strategic Leadership', assignedAt: '2024-01-01', contributions: ['Vision', 'Architecture decisions'] },
      { crewMemberId: 'commander_data', role: 'Technical Implementation', assignedAt: '2024-01-01', contributions: ['RAG system', 'Analytics'] },
      { crewMemberId: 'geordi_la_forge', role: 'Infrastructure', assignedAt: '2024-01-01', contributions: ['AWS', 'Docker', 'CI/CD'] },
      { crewMemberId: 'counselor_troi', role: 'UX Design', assignedAt: '2024-01-01', contributions: ['UI patterns', 'User research'] },
      { crewMemberId: 'quark', role: 'Business Strategy', assignedAt: '2024-01-01', contributions: ['Monetization', 'Cost analysis'] },
    ],
    
    monetization: {
      model: 'platform',
      targetPrice: 'Variable per project',
      revenueStreams: ['SaaS subscriptions', 'Consulting', 'Implementation packages'],
      timeline: 'Ongoing',
    },
    targetMarket: ['AI teams', 'Enterprise', 'Startups'],
    
    techStack: {
      frontend: ['Next.js 16', 'React 19', 'TypeScript'],
      backend: ['Next.js API Routes', 'Node.js'],
      infrastructure: ['AWS EC2', 'Docker', 'Terraform', 'GitHub Actions'],
      ai: ['RAG', 'TF-IDF', 'Supabase pgvector'],
      other: ['n8n workflows'],
    },
    
    mvpFeatures: [
      'Multi-project management',
      'Category scorecards',
      'RAG-powered search',
      'Natural language deployment',
      'Crew collaboration system',
    ],
    completedFeatures: [
      'Project creation wizard',
      'Domain dashboards',
      'CI/CD pipeline',
      'Cost tracking',
    ],
    milestones: [],
    
    successMetrics: [
      'Projects generated',
      'Domain coverage',
      'Deployment frequency',
      'RAG query accuracy',
    ],
    notes: 'The factory that builds factories.',
    tags: ['meta', 'factory', 'platform'],
  };
}

/**
 * Get all child projects of a parent
 */
export function getChildProjects(projects: Project[], parentId: string): Project[] {
  return projects.filter(p => p.parentId === parentId);
}

/**
 * Build a project tree structure
 */
export interface ProjectTreeNode {
  project: Project;
  children: ProjectTreeNode[];
  depth: number;
}

export function buildProjectTree(projects: Project[], rootId: string = FACTORY_PROJECT_ID, depth: number = 0): ProjectTreeNode | null {
  const project = projects.find(p => p.id === rootId);
  if (!project) return null;
  
  const children = projects
    .filter(p => p.parentId === rootId)
    .map(child => buildProjectTree(projects, child.id, depth + 1))
    .filter((node): node is ProjectTreeNode => node !== null);
  
  return {
    project,
    children,
    depth,
  };
}

/**
 * Calculate aggregate progress across a project tree
 */
export function calculateTreeProgress(node: ProjectTreeNode): number {
  if (node.children.length === 0) {
    return node.project.progress;
  }
  
  const childProgress = node.children.reduce((sum, child) => sum + calculateTreeProgress(child), 0);
  const avgChildProgress = childProgress / node.children.length;
  
  // Weight: 60% own progress, 40% children progress
  return Math.round(node.project.progress * 0.6 + avgChildProgress * 0.4);
}





