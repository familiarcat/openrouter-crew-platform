{
  "id": "mcp-GdtzqaEseO1i4Ttb",
  "name": "ANTI-HALLUCINATION - Crew Detection - OpenRouter - Production",
  "description": "Converted from n8n workflow: ANTI-HALLUCINATION - Crew Detection - OpenRouter - Production",
  "version": "1.0.0",
  "active": true,
  "nodes": [
    {
      "id": "b5791085-dfd9-471d-8d0c-00a39ea2eb12",
      "name": "Prompt Interception",
      "type": "mcp.webhook",
      "originalType": "n8n-nodes-base.webhook",
      "position": [
        240,
        300
      ],
      "parameters": {
        "httpMethod": "POST",
        "path": "anti-hallucination",
        "responseMode": "responseNode",
        "options": {},
        "webhookUrl": "https://n8n.pbradygeorgen.com/webhook/anti-hallucination"
      },
      "webhookInfo": {
        "path": "anti-hallucination",
        "method": "POST",
        "responseMode": "responseNode",
        "note": "⚠️ WEBHOOK EXECUTION POINT: This webhook can be executed via MCP at /api/workflows/execute with webhook path"
      },
      "metadata": {
        "converted": true,
        "originalNode": "Prompt Interception"
      }
    },
    {
      "id": "bb9eaafd-d4e2-4360-8295-84a01a312f2f",
      "name": "Prompt Analysis",
      "type": "mcp.transform",
      "originalType": "n8n-nodes-base.function",
      "position": [
        460,
        300
      ],
      "parameters": {
        "functionCode": "// Analyze prompt context and prepare for crew activation\nconst prompt = $input.first().json.prompt;\nconst timestamp = new Date().toISOString();\n\n// Extract prompt metadata\nconst promptContext = {\n  text: prompt,\n  length: prompt.length,\n  timestamp: timestamp,\n  domain: detectDomain(prompt),\n  complexity: detectComplexity(prompt),\n  type: detectPromptType(prompt)\n};\n\n// Detect domain from prompt\nfunction detectDomain(prompt) {\n  const domains = {\n    'machine-learning': ['ml', 'ai', 'model', 'training', 'neural'],\n    'security': ['security', 'vulnerability', 'threat', 'attack'],\n    'psychology': ['emotion', 'behavior', 'psychology', 'mental'],\n    'engineering': ['code', 'architecture', 'system', 'design'],\n    'strategy': ['strategy', 'planning', 'leadership', 'management']\n  };\n  \n  const lowerPrompt = prompt.toLowerCase();\n  for (const [domain, keywords] of Object.entries(domains)) {\n    if (keywords.some(keyword => lowerPrompt.includes(keyword))) {\n      return domain;\n    }\n  }\n  return 'general';\n}\n\n// Detect complexity level\nfunction detectComplexity(prompt) {\n  const highComplexityKeywords = ['complex', 'advanced', 'sophisticated', 'comprehensive'];\n  const mediumComplexityKeywords = ['explain', 'describe', 'analyze', 'compare'];\n  \n  const lowerPrompt = prompt.toLowerCase();\n  if (highComplexityKeywords.some(keyword => lowerPrompt.includes(keyword))) {\n    return 'high';\n  } else if (mediumComplexityKeywords.some(keyword => lowerPrompt.includes(keyword))) {\n    return 'medium';\n  }\n  return 'low';\n}\n\n// Detect prompt type\nfunction detectPromptType(prompt) {\n  const technicalKeywords = ['code', 'algorithm', 'technical', 'system'];\n  const creativeKeywords = ['creative', 'design', 'artistic', 'innovative'];\n  const analyticalKeywords = ['analyze', 'evaluate', 'compare', 'assess'];\n  const empathicKeywords = ['feel', 'emotion', 'empathy', 'understand'];\n  const strategicKeywords = ['strategy', 'plan', 'leadership', 'vision'];\n  \n  const lowerPrompt = prompt.toLowerCase();\n  if (technicalKeywords.some(keyword => lowerPrompt.includes(keyword))) return 'technical';\n  if (creativeKeywords.some(keyword => lowerPrompt.includes(keyword))) return 'creative';\n  if (analyticalKeywords.some(keyword => lowerPrompt.includes(keyword))) return 'analytical';\n  if (empathicKeywords.some(keyword => lowerPrompt.includes(keyword))) return 'empathic';\n  if (strategicKeywords.some(keyword => lowerPrompt.includes(keyword))) return 'strategic';\n  return 'analytical';\n}\n\nreturn {\n  promptContext,\n  originalPrompt: prompt,\n  processingId: `ah_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n};"
      },
      "webhookInfo": null,
      "metadata": {
        "converted": true,
        "originalNode": "Prompt Analysis"
      }
    },
    {
      "id": "2a649373-f518-448c-a412-58739004572f",
      "name": "Crew Splitter",
      "type": "mcp.transform",
      "originalType": "n8n-nodes-base.function",
      "position": [
        680,
        300
      ],
      "parameters": {
        "functionCode": "// Split prompt context for crew member processing\nconst promptContext = $input.first().json;\nconst crewMembers = [\n  'Captain Picard',\n  'Commander Data', \n  'Counselor Troi',\n  'Lieutenant Worf',\n  'Commander Riker',\n  'Lieutenant Commander La Forge',\n  'Doctor Crusher',\n  'Lieutenant Commander Tasha Yar',\n  'Lieutenant Commander Spock'\n];\n\n// Create individual crew member tasks\nconst crewTasks = crewMembers.map(crewMember => ({\n  crewMember,\n  promptContext: promptContext.promptContext,\n  originalPrompt: promptContext.originalPrompt,\n  processingId: promptContext.processingId,\n  timestamp: new Date().toISOString()\n}));\n\nreturn crewTasks;"
      },
      "webhookInfo": null,
      "metadata": {
        "converted": true,
        "originalNode": "Crew Splitter"
      }
    },
    {
      "id": "917a0856-f7dd-4b77-b655-a19137bbf497",
      "name": "LLM Optimization",
      "type": "mcp.transform",
      "originalType": "n8n-nodes-base.function",
      "position": [
        900,
        300
      ],
      "parameters": {
        "functionCode": "// Optimize LLM selection for crew member\nconst crewTask = $input.first().json;\nconst { crewMember, promptContext } = crewTask;\n\n// Crew member expertise mapping\nconst crewExpertise = {\n  'Captain Picard': ['leadership', 'strategy', 'diplomacy', 'ethics'],\n  'Commander Data': ['technical-analysis', 'logic', 'computation', 'science'],\n  'Counselor Troi': ['empathy', 'psychology', 'counseling', 'emotions'],\n  'Lieutenant Worf': ['security', 'tactics', 'combat', 'honor'],\n  'Commander Riker': ['leadership', 'tactics', 'diplomacy', 'command'],\n  'Lieutenant Commander La Forge': ['engineering', 'technology', 'innovation'],\n  'Doctor Crusher': ['medical', 'healing', 'science', 'research'],\n  'Lieutenant Commander Tasha Yar': ['security', 'tactics', 'survival'],\n  'Lieutenant Commander Spock': ['logic', 'science', 'analysis']\n};\n\n// LLM optimization based on context and expertise\nfunction selectOptimalLLM(crewMember, context) {\n  const expertise = crewExpertise[crewMember] || ['general'];\n  \n  // Context-based LLM selection\n  if (context.type === 'technical' && expertise.includes('technical-analysis')) {\n    return 'openai/gpt-4-turbo';\n  }\n  if (context.type === 'empathic' && expertise.includes('empathy')) {\n    return 'anthropic/claude-3-sonnet';\n  }\n  if (context.type === 'strategic' && expertise.includes('leadership')) {\n    return 'anthropic/claude-3-opus';\n  }\n  if (context.type === 'analytical' && expertise.includes('logic')) {\n    return 'openai/gpt-4-turbo';\n  }\n  \n  // Default LLM selection\n  if (expertise.includes('technical-analysis') || expertise.includes('logic')) {\n    return 'openai/gpt-4-turbo';\n  }\n  return 'anthropic/claude-3-sonnet';\n}\n\nconst optimalLLM = selectOptimalLLM(crewMember, promptContext);\nconst confidence = Math.random() * 0.3 + 0.7; // Simulate confidence between 0.7-1.0\n\nreturn {\n  ...crewTask,\n  optimalLLM,\n  confidence,\n  reasoning: `Selected ${optimalLLM} for ${crewMember} based on ${promptContext.type} context and ${crewExpertise[crewMember].join(', ')} expertise`\n};"
      },
      "webhookInfo": null,
      "metadata": {
        "converted": true,
        "originalNode": "LLM Optimization"
      }
    },
    {
      "id": "09db831e-340c-4c50-8fcf-a208b3d9f97a",
      "name": "Crew Response Generation",
      "type": "mcp.http",
      "originalType": "n8n-nodes-base.httpRequest",
      "position": [
        1120,
        300
      ],
      "parameters": {
        "url": "https://api.openrouter.ai/api/v1/chat/completions",
        "authentication": "genericCredentialType",
        "requestMethod": "POST",
        "headers": {
          "Content-Type": "application/json"
        },
        "body": {
          "model": "anthropic/claude-3.5-sonnet",
          "messages": [
            {
              "role": "user",
              "content": "{{ $json.prompt || $json.message || \"Analyze this prompt for potential hallucinations\" }}"
            }
          ],
          "temperature": 0.7,
          "max_tokens": 1000
        },
        "options": {}
      },
      "webhookInfo": null,
      "metadata": {
        "converted": true,
        "originalNode": "Crew Response Generation"
      }
    },
    {
      "id": "1faa6a13-8e8d-4111-934f-1e8a9222a3cf",
      "name": "Response Processing",
      "type": "mcp.transform",
      "originalType": "n8n-nodes-base.function",
      "position": [
        1340,
        300
      ],
      "parameters": {
        "functionCode": "// Process crew member response\nconst input = $input.first().json;\nconst crewTask = input.crewTask || input;\nconst llmResponse = input.choices?.[0]?.message?.content || 'No response generated';\n\nreturn {\n  crewMember: crewTask.crewMember,\n  response: llmResponse,\n  llmUsed: crewTask.optimalLLM,\n  confidence: crewTask.confidence,\n  timestamp: new Date().toISOString(),\n  context: crewTask.originalPrompt,\n  optimization: {\n    crewMember: crewTask.crewMember,\n    promptContext: JSON.stringify(crewTask.promptContext),\n    personaSkills: crewTask.promptContext.domain,\n    optimalLLM: crewTask.optimalLLM,\n    confidence: crewTask.confidence,\n    reasoning: crewTask.reasoning,\n    timestamp: crewTask.timestamp\n  }\n};"
      },
      "webhookInfo": null,
      "metadata": {
        "converted": true,
        "originalNode": "Response Processing"
      }
    },
    {
      "id": "65e65d72-f3ea-4908-814a-734ec56fa3e6",
      "name": "Hallucination Analysis",
      "type": "mcp.transform",
      "originalType": "n8n-nodes-base.function",
      "position": [
        1560,
        300
      ],
      "parameters": {
        "functionCode": "// Collect all crew perspectives and analyze for hallucinations\nconst crewPerspectives = $input.all().map(item => item.json);\n\nif (crewPerspectives.length < 2) {\n  return {\n    error: 'Insufficient crew responses for consensus analysis',\n    perspectives: crewPerspectives\n  };\n}\n\n// Calculate consensus (simplified)\nconst responses = crewPerspectives.map(p => p.response);\nconst consensusResponse = responses[Math.floor(Math.random() * responses.length)]; // Simplified consensus\nconst consensusConfidence = crewPerspectives.reduce((sum, p) => sum + p.confidence, 0) / crewPerspectives.length;\n\n// Analyze for hallucinations (simplified deviation detection)\nconst hallucinationAnalyses = crewPerspectives.map(perspective => {\n  // Simple deviation calculation based on response length and keywords\n  const responseLength = perspective.response.length;\n  const avgLength = responses.reduce((sum, r) => sum + r.length, 0) / responses.length;\n  const lengthDeviation = Math.abs(responseLength - avgLength) / avgLength;\n  \n  // Simple keyword similarity check\n  const responseWords = perspective.response.toLowerCase().split(/\\s+/);\n  const consensusWords = consensusResponse.toLowerCase().split(/\\s+/);\n  const commonWords = responseWords.filter(word => consensusWords.includes(word));\n  const similarity = commonWords.length / Math.max(responseWords.length, consensusWords.length);\n  \n  const deviationScore = (lengthDeviation * 0.3) + ((1 - similarity) * 0.7);\n  const isHallucination = deviationScore > 0.3; // Threshold\n  \n  return {\n    crewMember: perspective.crewMember,\n    isHallucination,\n    deviationScore,\n    consensusAlignment: 1 - deviationScore,\n    correctionPrompt: isHallucination ? `Your response deviated from crew consensus. Please revise: ${consensusResponse}` : '',\n    learningOpportunity: isHallucination ? `Learning opportunity for ${perspective.crewMember}: improve consensus alignment` : '',\n    detectedAt: new Date().toISOString(),\n    severity: deviationScore > 0.7 ? 'high' : deviationScore > 0.5 ? 'medium' : 'low'\n  };\n});\n\nconst hallucinationsDetected = hallucinationAnalyses.filter(a => a.isHallucination);\nconst overallHealth = 1 - (hallucinationsDetected.length / crewPerspectives.length);\n\nreturn {\n  perspectives: crewPerspectives,\n  consensus: {\n    consensusResponse,\n    consensusConfidence,\n    participantCount: crewPerspectives.length,\n    agreementScore: overallHealth,\n    dominantPerspective: crewPerspectives[0]?.crewMember,\n    outlierCount: hallucinationsDetected.length\n  },\n  analyses: hallucinationAnalyses,\n  overallHealth,\n  hallucinationsDetected: hallucinationsDetected.length,\n  processingComplete: true\n};"
      },
      "webhookInfo": null,
      "metadata": {
        "converted": true,
        "originalNode": "Hallucination Analysis"
      }
    },
    {
      "id": "c3aa980e-919a-47cb-974c-75b32bf2d216",
      "name": "Response Return",
      "type": "mcp.response",
      "originalType": "n8n-nodes-base.respondToWebhook",
      "position": [
        1780,
        300
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "webhookInfo": null,
      "metadata": {
        "converted": true,
        "originalNode": "Response Return"
      }
    }
  ],
  "edges": [
    {
      "id": "edge-Prompt Interception-Prompt Analysis",
      "source": "Prompt Interception",
      "target": "Prompt Analysis",
      "sourceHandle": "main-0",
      "targetHandle": "input"
    },
    {
      "id": "edge-Prompt Analysis-Crew Splitter",
      "source": "Prompt Analysis",
      "target": "Crew Splitter",
      "sourceHandle": "main-0",
      "targetHandle": "input"
    },
    {
      "id": "edge-Crew Splitter-LLM Optimization",
      "source": "Crew Splitter",
      "target": "LLM Optimization",
      "sourceHandle": "main-0",
      "targetHandle": "input"
    },
    {
      "id": "edge-LLM Optimization-Crew Response Generation",
      "source": "LLM Optimization",
      "target": "Crew Response Generation",
      "sourceHandle": "main-0",
      "targetHandle": "input"
    },
    {
      "id": "edge-Crew Response Generation-Response Processing",
      "source": "Crew Response Generation",
      "target": "Response Processing",
      "sourceHandle": "main-0",
      "targetHandle": "input"
    },
    {
      "id": "edge-Response Processing-Hallucination Analysis",
      "source": "Response Processing",
      "target": "Hallucination Analysis",
      "sourceHandle": "main-0",
      "targetHandle": "input"
    },
    {
      "id": "edge-Hallucination Analysis-Response Return",
      "source": "Hallucination Analysis",
      "target": "Response Return",
      "sourceHandle": "main-0",
      "targetHandle": "input"
    }
  ],
  "webhookExecutionPoints": [
    {
      "nodeId": "b5791085-dfd9-471d-8d0c-00a39ea2eb12",
      "nodeName": "Prompt Interception",
      "webhookPath": "anti-hallucination",
      "webhookMethod": "POST",
      "mcpExecutionPath": "/api/workflows/execute?webhook=anti-hallucination",
      "note": "⚠️ WEBHOOK EXECUTION POINT: This webhook can be executed via MCP at /api/workflows/execute with webhook path"
    }
  ],
  "metadata": {
    "originalWorkflowId": "GdtzqaEseO1i4Ttb",
    "convertedAt": "2025-11-21T14:24:04.671Z",
    "originalName": "ANTI-HALLUCINATION - Crew Detection - OpenRouter - Production"
  }
}